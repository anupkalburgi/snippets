65536


"""[summary]
aggressive cows 
we have to find maximum how far apart we can keep them
array of stalls = S
number of cows = C 

for i in 1 to S:
    possible_to_place_at_distance(i)

so see that we can use binary search, 
but how am I going to say that an optimization is not possible at how to place ?
but there is clearly a optimization possible at seeing where we can place the cows 


"""


def can_place(stalls, no_cows, distance):
    last_placed_at = None

    for stall in stalls:
        if last_placed_at is None:
            last_placed_at = stall
            no_cows = no_cows - 1
        else:
            if stall - last_placed_at >= distance:
                last_placed_at = stall
                no_cows = no_cows - 1
    return True if no_cows == 0 else False


def max_distance(stalls, no_cows, low, high):
    if low >= high:
        return low
    else:
        mid = (high + low) // 2
        if can_place(stalls, no_cows, mid):
            return max_distance(stalls, no_cows, mid, high)
        else:
            return max_distance(stalls, no_cows, low, mid-1)


"""[summary]
longest increasing subsequence

"""


def lis_sum(arr, prev, curr):
    if curr >= len(arr):
        return 0
    else:
        c1 = 0
        if arr[prev] < arr[curr] or prev == -1:
            c1 = arr[curr] + lis_sum(arr, curr, curr+1)
        c2 = lis_sum(arr, prev, curr+1)
        return max(c1, c2)


print(lis_sum([4, 1, 2, 6, 10, 1, 12], -1, 0))


def lis_sum_dp(arr):
    dp = [0 for _ in range(len(arr)+1)]
    max_sum = 0
    for curr in range(1, len(arr)):
        dp[curr] = arr[curr]
        for prev in range(curr):
            if arr[curr] > arr[prev] and dp[curr] <= dp[prev] + arr[curr]:
                dp[curr] = dp[prev] + arr[curr]
            max_sum = max(max_sum, dp[curr])
    return max_sum


print(lis_sum_dp([4, 1, 2, 6, 10, 1, 12]))


def subseq(arr):
    if len(arr) == 0:
        return [[]]
    else:
        xh, xt = arr[0], arr[1:]
        subs = subseq(xt)
        return [[xh] + xss for xss in subs] + subs


print("#"*100)
print(len(subseq([1])))
print(len(subseq([1, 3])))
print(len(subseq([1, 3, 4])))
print(len(subseq([1, 3, 4, 10])))


"""
finding peak
can do a linear scan, 
    1 
    0 < 1 > 2
    return i

    binary search, 

    """
def local_peak(arr, low, high):
    if low >= high:
        return low
    else:
        mid = (low+high) // 2
        if arr[mid] < arr[mid+1]:
            return local_peak(arr, mid+1, high)
        else:
            return local_peak(arr, low, mid)

print("-"*10)
print(local_peak([1,2,1,3,5,6,4], 0, 6))
# TODO vim, ctrl+u and ctrl+d

#convinced
# barrage 
# virtuosity 