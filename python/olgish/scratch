"""
count the number of elements  smaller on the right, 
here the insight is to use merege sort to find the number of jumps that are happening from right to left partition
use the num class for easy mutation instead of named tuple 

"""
class Num:
    def __init__(self, value, inx, count):
        self.num = value 
        self.idx = inx
        self.count = 0
    def __repr__(self):
        return f'Num(num={self.num}, idx={self.idx}, count={self.count})'


def merge(left , right):
    if len(left) == 0:
        return right
    if len(right) == 0:
        return left
    else:
        lh, lt = left[0], left[1:]
        rh, rt = right[0], right[1:]
        if lh.num < rh.num: # no jump
            return [lh] + merge(lt, right)
        else: # juming over the left element, there are elements that are smaller
            for l in left:
                l.count= l.count + 1
            return [rh] + merge(left, rt)
    

def merge_sort(A):
    if len(A) <= 1:
        return A 
    else: # divide
        mid = len(A) // 2 
        left = merge_sort(A[:mid])
        right = merge_sort(A[mid:])
        return merge(left, right) #conquer
A = [5, 2, 6, 1]
nums = []
for idx, num in enumerate(A):
    nums.append(Num(num, idx, 0))
print(nums)
ssr = merge_sort(nums)
srted = sorted(ssr, key=lambda x: x.idx)
print([x.count for x in srted])



"""
three number combination

"""

def three_comb(A, target):
    xs = sorted(A)
    answers = []
    for i in range(xs):
        l = i+1
        r = len(xs)-1
        while l <= r:
            ssum = sum(xs[i], xs[l], xs[r])
            if ssum == target:
                answers.append(i, l, r)
                l = l+1
                r = r+1
            if ssum < target:
                l = l  + 1
            else:
                r = r-1
    return answers


import collections
Point = collections.namedtuple('Point', field_names=['x', 'y'])
# mutation is not possile

def smaller_than(A, target):
    l, r = 0, len(A)-1

    while l < r:
        mid = (l + r) // 2

        if A[mid] >= target:
            r = mid
        else: # A[mid] > target
            l =  mid+1
    return l

print(smaller_than([1, 2, 4, 7, 9], 3)) # 1
print(smaller_than([1, 2, 4, 7, 9], 8)) # 3

"""
convinced
convinced
"""