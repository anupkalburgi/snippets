# can be a binary search 
# or reduction based recusion that is becaue the the there is natural base condition

def sqrt(x):
    if x <=1:
        return x
    else:
        left = 2 * sqrt(x // 4) # sqrt(x >> 2) << 1
        right = left + 1
        return left if right > x * x else right

# TODO: this 
def bsqrt(x, l, r):
    """
    the sqrt of x must be between 0 and x 
    mid = (l+r ) /  2 
    if mid+1 *mid +1 == x:
        return mid 
    elif mid+1*mid+1 < x:
        return bsqrt(x, mid+1, r)
    else:
        return bsqrt(x, l, mid)

    bsqrt(8, 0, 7)
    mid = (0+7)/2 = 3 
    sqrd = mid+1*mid+1  (16)

    bsqrt(8, 0, 3)
    mid = (0 + 3) // 2 = 1 
    sqrd = 1+1 * 1+1 = 4

    bsqrt(8, 2, 3)
    mid = (2+3)/2 = (5/2) = 2
    sqrd = 3 * 3 = 9
    bsqrt(8, 2, 2)


    """



def dfs(graph, node, visited):
    if node not in visited:
        visited.add(node)
        for neighbour in graph[node]:
            if neighbour not in visited:
                dfs(graph, neighbour, visited)

def dfs_iterative(graph, node):
    stack = [node]
    visited  = set()
    path = []
    while stack:
        n = stack.pop()
        visited.add(n)
        path.append(n)
        for neighbour in graph[n]:
            stack.append(neighbour)
    
    return path


# product array, excluding self
def prod_array(A):
    """
    5,1,4,2 
    1,5,5,20
    8,8,2,1 
    8,40,10,20
    output array has to hold prod of all the elements expect it self
    n^2 sol is easy, 
    for a linear one
        we can do 2 scans, on left and right, leaving out itself on both direction
        the result, we would scan both and multiply the l[i] * r[i] (both will products till that point excluding it self )

    """
    left = [1 for _ in range(len(A))]
    right = [1 for _ i range(len(A))] 

    for i in range(1, len(A)):
        left[i] = A[i-1] * left[i-1]
    for i in range(len(A)-2, -1, -1):
        right[i] = right[i+1] * A[i+1]
    result = []
    for i in range(len(A)):
        result.append(left[i]* right[i])


# TODO:copy the modifed code here, the size is use less 
def longest_subsequence(s1, s2, i, j, size):
    """
    if i == len(s1) or j == len(s2):
        return 0
    if s1 == s2 
        return  1 + longest_subsequence(s1, s2, i+1, j+1, size)
    else:
        return max(
            longest_subsequence(s1, s2, i+1, j, size),
            longest_subsequence(s1, s2, i, j+1, size)
        )
    """
    return None


def neighbour(r, c, rlen, clen):
    nghs = [(r, c-1),(r-1, c), (r, c+1), (r+1, c)]
    valid = []
    for (nr, nc) in nghs:
        if 0  nr <= rlen and 0 <= nc <= clen:
            valid.append((nr,nc))
    return valid

def bfs(grid, r, c, visited): 
    """
    we start form a land

    """
    q = [(r, c)]
    length = 0
    

    while q:
        (nr, nc) = q.pop(0) # only lands are added to the queue
        length = length  + 1
        for (nnr, nnc) in neighbours(nr, nc, rlen, clen):
            if grid[nnr][nnc] == 1 and (nnr, nnc) not in visited:
                q.append((nnr, nnc))
            visited.add((nnr,nnc))


    return length
visited = set()
max_land_size = 0
for i in range(grid):
    for j in range(gird[0]):
        if gird[i][j] == 1:
            land_size  = bfs(grid, i, j, visited)
            max_land_size = max(land_size, max_land_size)
return max_land_size

with actor_films as (
    select actor_id, count(*)
    from film_actor
    group by 1
    order by 2 desc
    limit 1
)
select first_name, last_name
from actor
where actor_id in (select actor_id from actor_films)


(film_id, category, length)
with film_len as(
    select film_id,
    length, 
    category,
    row_number() over (partition by category order by legth)
    from films

)

select film_id, legth, category 
from film_len 
where row_number = 1

select
    rental_id, 
    customer_id,
    LAG(amount, 1) over (partition by customer_id order by rental_time) as prev_amount, (for 1st that is going to be null)
    row_number() over (partition by customer_id order by rental_time) as row_num
from rental 

consequences  
hectic
heuristic 