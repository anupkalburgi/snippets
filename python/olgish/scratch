# graph, connected_components , wording needs to be fixed 


def all_substring(lst):
    subs = []
    for i in range(len(lst)+1):
        for j in range(i+1, len(lst)+1):
            subs.append(lst[i:j])
    return subs


print(all_substring("abc"))


def subsets(lst):
    if len(lst) == 0:
        return [[]]
    else:
        x, xs = lst[0], lst[1:]
        subs = subsets(xs)
        return subs + [[x] + xss for xss in subs]
    
print(subsets([1,2,3]))

# fix wording in generate all possible substrings for given string  and fix the code

# this can be solved vis leveled bfs, but the tree needs to be viewed ad graph and not as tee
# 1. construct a mapping from node -> parent 
# 2. do bfs for each queue size 

def nodes_at_dist(root, target, l):
    node_parent_mapping = {} # this will need to be constructed via tree traversal

    def cons_mapping(subtree, parent):
        if subtree is None:
            return 
        else:
            if parent:
                node_parent_mapping[subtree.val] = parent
            cons_mapping(subtree.left, subtree.val)
            cons_mapping(subtree.right, subtree.val)

    q = [target]
    visited = set()
    while q and l > 0:
        l = l -1 
        qsize = len(q)
        for _ in range(qsize):
            node = q.pop(0)
            if node in node_parent_mapping.keys() and node not in visited:
                q.append(node_parent_mapping[node])
                visited.add(node_parent_mapping[node])
            if node.left and node.left not in visited:
                q.append(node.left)
            if node.right and node.right not in visited:
                q.append(node.right)
    return q

# number of inserts or deletes needed to convert a string to another
# 1. ns = find the longest subsequence[s1, s2]
# 2. delete non common chars  len(s1) - ns  
# 3. insert non common chars len(s2) - ns

def lcs(s1, s2, i, j, size ):
    if i == len(s1) or j == len(s2):
        return size
    else:
        if s1[i] == s2[j]:
            return lcs(s1, s2, i+1, j+1, size+1)
        else:
            return max(
                lcs(s1, s2, i, j+1, size),
                lcs(s1, s2, i+1, j, size)
            )
def del_ins(s1, s2):
    ns = lcs(s1, s2, 0, 0, 0)
    return ((len(s1)- ns), (len(s2)-ns))

print(del_ins("abc", "fbc"))



def lis(nums, prev, curr):
    if len(nums) == curr:
        return 0
    else:
        c1 = 0
        if nums[prev] < nums[curr] or prev == -1:
            c1 = 1+lis(nums, curr, curr+1)
        c2 = lis(nums, prev, curr+1)
        return max(c1, c2)

print(lis([-4, 10, 3, 7, 15], -1, 0))


"""
with rentals as (
    select customer_id,
        rental_ts,
        ROW_NUMBER() over (partition by customer_id order by rental_ts),
    from rental
)

select customer_id, date(rental_ts) 
from rentals
where row_number = 10 

"""