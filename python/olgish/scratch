

# burte force
# recursion
# memoization 
# dp
# a binary search based impl - which i have not undertood

# burte force genertate all the subsequences
# filter out the onces that have only increasing sequences 
# get the maximum count of that 

# recusion
## we will have two recursive calls, that
#  1, if the current element is greater then the previous
#  2, the possibility of a lis starting at the current poition, leaving the old one
# the complexity is 2^n a exponential growth

# recusion using memoization
# the complexity comes down to quadratic time 
# DP - using a array

def lis_dp(array):
    dp = [1 for _ in range(len(array)+1)] 
    max_len = 0
    for i in range(1, len(array)):
        for j in range(i):
            if array[j] < array[i] and dp[j] >= dp[i]:
                dp[i] = dp[j] + 1
                max_len = max(max_len, dp[i])
    return max_len

print(lis_dp([-4, 10, 3, 7, 16]))
            
# TODO fix the code in the notes for DP solution


def substrings(lst):
    subbs = []
    for i in range(len(lst)+1):
        for j in range(i, len(lst)+1):
            if len(lst[i:j]) != 0:
                subbs.append(lst[i:j])
    return subbs

print(substrings("abc"))

def subsequence(lst):
    if len(lst) == 0:
        return [[]]
    else:
        x, xs = lst[0], lst[1:]
        subs = subsequence(xs)
        print(subs)
        return subs + [[x] + xxs for xxs in subs]

print(subsequence([1,2,3]))