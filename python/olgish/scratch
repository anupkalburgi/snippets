"""[summary]
1NF - Make sure the fields are atomic 
2NF - dependency needs to  be moved out a differnt table, the values must depend on the full primary key, rather than just a part of it 
3NF - has to do with transitive dependencies 
    should not have repeated lines
"""

# longest increasing sum subsequence
""""[summary]"

burte force 
    generate all the subsequences
    filter the increasing onces
    get the maximim one

recursion
    if prev < curr:
        lis(arr, curr, curr+1)
    lis(prev, curr+1)

next is memoization
next is dp

"""
def subsequences(arr):
    if len(arr) == 0:
        return [[]]
    else:
        x, xs = arr[0], arr[1:]
        subs = subsequences(xs)
        return [[x]+ xxs for xxs in subs] + subs
def filter_inc(sub):
    for i in range(1, len(sub)):
        if sub[i-1] > sub[i]:
            return False
    return True

def lis(arr):
    subs = list(subsequences(arr))
    subss = list(map(sum, filter(filter_inc, subs)))
    return max(subss)
## update the brute force solution 
def lis_rec(arr, prev, curr):
    if curr == len(arr):
        return 0
    else:
        c1 =0
        if arr[prev] < arr[curr] or prev == -1:
            return arr[curr] + lis_rec(arr, curr, curr+1)
        c2 = lis_rec(arr, prev, curr+1)
        return max(c1, c2)

def lis_dp(arr):
    dp = [0 for _ in range(len(arr))]
    max_sum = 0
    dp[0] = arr[0]
    for curr in range(1, len(arr)):
        dp[curr] = arr[curr]
        for prev in range(curr):
            if arr[curr] > arr[prev] and dp[curr] <= arr[curr] + dp[prev]:
                dp[curr] = dp[prev] + arr[curr]
                max_sum = max(dp[curr], max_sum)
    return max_sum



print(lis([4, 1, 2, 6, 10, 1, 12]))
print(lis_rec([4, 1, 2, 6, 10, 1, 12], -1, 0))
print(lis_dp([4, 1, 2, 6, 10, 1, 12]))



def bfs(arr, target ,left , right):
    if left > right:
        return -1
    else:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] > target:
            return bfs(arr, target, left, mid)
        else:
            return bfs(arr, target, mid+1, right)


print(bfs([1,3,4,6,9,19], 6, 0, 5))
