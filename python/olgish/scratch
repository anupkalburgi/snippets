def subsets(arr):
    if len(arr) == 0:
        return [[]]
    else:
        x,  xs = arr[0], arr[1:]
        subs = subsets(xs)
        return [[x]+ xss for xss in subs] + subs

    """[summary]
    this is also the subsequence, and there are 2^n number of these
    """

# print(len(subsets("a")))
# print(len(subsets("ab")))
# print(len(subsets("abc")))
# print(len(subsets("abcd")))
# print(len(subsets("abcde")))
# print(len(subsets("abcdef")))

class Node:
    def __init__(self, value):
        self.val = value
        self.left = None
        self.right = None

    def __repr__(self) -> str:
        return f"Node(val={self.val}, left={self.left}, right={self.right}"

    
def nearest_node(root, target):
    """
    going take iterative approach here
    
    Args:
        root ([type]): [description]
    """

    diff = 9999999
    nearest_node = None
    while root is not None:
        if abs(root.val - target) < diff:
            nearest_node = root
            diff = abs(root.val - target)
        if root.val > target:
            root = root.left
        else:
            root = root.right
    return nearest_node
root = Node(4)
n3 = Node(3)
n1 = Node(1)

root.left = n3
n3.left = n1

# print(nearest_node(root, 2.1))
print("-----------------")
def lcs(s1, s2, i, j, cmn):
    if len(s1) == i or len(s2) == j:
        return cmn
    else:
        if s1[i] == s2[j]:
            cmn = lcs(s1, s2, i+1, j+1, cmn+1)
        c2 = lcs(s1, s2, i+1, j , 0)
        c3 = lcs(s1, s2, i, j+1, 0)
        return max(cmn, c2, c3)

def lcs_dp(s1, s2):
    dp = [[0 for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]
    max_len = 0

    for i in range(1, len(s1)+1):
        for j in range(1, len(s2)+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
                max_len = max(max_len, dp[i][j])
    return max_len

print(lcs("abc", "adbfc", 0, 0, 0)) # 3
print(lcs_dp("abc", "adbfc"))
print("passport", "ppsspt", "expect 3 ->" , lcs("passport", "ppsspt", 0 ,0, 0  ))
print(lcs_dp("passport", "ppsspt"))