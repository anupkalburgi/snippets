# longest subsequence
# burte force , recursion, memoization and dp 

def subsequence(lst):
    if len(lst) == 0:
        return [[]]
    else:
        x, xs = lst[0], lst[1:]
        subs = subsequence(xs)
        return subs + [[x] + xss for xss in subs]
def burte_lcs(s1, s2):
    # produce all the subsequences filter the once that match and get the largest one 
    s1s = subsequence(s1)
    s2s = subsequence(s2)
    max_len = 0 
    for ss1 in s1s:
        for ss2 in s2s:
            if ss1 == ss2:
                max_len = max(max_len, len(ss1))
    return max_len

# recursion 

def lcs_rec(s1, s2, i, j):
    if len(s1) == i or len(s2) == j:
        return 0
    else:
        c1 = 0
        if s1[i] == s2[j]:
            c1 = 1 + lcs_rec(s1, s2, i+1, j+1)
        c2 = lcs_rec(s1, s2, i+1, j)
        c3 = lcs_rec(s1, s2, i, j+1)
        return max(c1, c2, c3)

# we can use memoization to avoid recomputing the subtrees 

# but jumping to dp problem 
def lcs_dp(s1, s2):
    dp = [[0 for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]
    # using row 0 and col 0 as starting points 
    # WARNING: the string compare starts form the 1st elm not the 2nd 
    max_len = 0

    for i in range(1, len(s1)+1):
        for j in range(1, len(s2)+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = 1 + dp[i-1][j-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            max_len = max(dp[i][j], max_len)
    
    return max_len

print(lcs_rec("abdca", "cbda", 0 , 0))
print(lcs_dp("abdca", "cbda"))
# print(longest_subsequence_dp("abdca", "cbda"))

# number of inserts and deletes necessary 
# s1 , s2 lcs => ln
# s1 => s2
# s1 - ln
# s2 - ln 


# spiral matrix
def spirl(grid):
    startRow = 0
    endRow  = len(grid)
    startCol = 0
    endCol = len(grid[0])
    while startRow <= endRow and startCol <= endCol:
        for col in range(startCol, endCol):
            print(startRow, col)
        
        for row in range(startRow, endRow):
            print(row, endCol)
        
        for col in range(endCol, startCol, -1):
            print(row, col)
        
        for row  in range(endRow, startRow, -1):
            print(row, col)
        startRow =  startRow +1
        endRow = endRow -1
        startCol = startCol + 1
        endCol = endCol -1

# stack sorting
# pattern to avoid  : 231 

def stack_sort(listr):
    stack = []
    result = []
    for x in listr:
        while stack and stack[0] < x:
            result.append(stack.pop())
        stack.append(x)
    
    while stack:
        result.append(stack.pop())
    return result
    

