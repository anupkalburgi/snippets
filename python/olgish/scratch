"""
closed left right open
- very usefull when we have to find the first largest element than given targer 
- 
"""
def bst_first_largest(arr, target):
   l , h = 0, len(arr)-1

   while l < h:
       mid = (l + h)  // 2
       if arr[mid] >= target:
           h = mid
       else:
            l = mid + 1
   return l

print(bst_first_largest([1,2,5,6,8],3)) 
# will have to insert into the the positon returned and shift the element that is there at i to i+1
# which will lead to n^2 complexity 
# it is good idea when the data structure is realtively static, example find 
# if the tree is skewed we will have a issue here too

# largest incresing subsequecne
"""
brute force solution
    generate all the subsequences, 
    filter the increasing subs
    give the max(sum(filtered))
    
resursive solution 
    at every element there are two possiblilities
        will add to the exiting seq
        or will start its own sequence 
        
    def lis(arr, prev, curr):
        if curr == len(arr):
            return 0
        else:
            c1 = 0 
            if arr[prev] < arr[curr] or prev = -1:
                c1 = lis(arr, curr, curr+1)
            c2 = lis(arr, prev, curr+1) # skipping the current element
            return max(c1, c2)
memo
dp
"""
def lis(arr, prev, curr):
    if curr == len(arr):
        return 0
    else:
        c1 = 0 
        if arr[prev] < arr[curr] or prev == -1:
            c1 = arr[curr] + lis(arr, curr, curr+1)
        c2 = lis(arr, prev, curr+1) # skipping the current element
        return max(c1, c2)
print(lis([2, 5, 1, 6 , 9], -1, 0))

def lis_dp(arr):
    dp = [0 for _ in range(len(arr))]
    dp[0] = arr[0]
    max_sum = 0 
    for curr in range(1, len(arr)):
        dp[curr] = arr[curr]
        for prev in range(curr):
            if arr[curr] > arr[prev] and dp[curr] <= arr[curr] + dp[prev]:
                dp[curr] = dp[prev] + arr[curr]  
                max_sum = max(max_sum, dp[curr])
    return max_sum
print(lis_dp([2, 5, 1, 6 , 9]))

"""
trepidation 
virtousity B
"""